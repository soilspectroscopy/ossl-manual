# Database

```{r, results="asis", echo=FALSE}
status("drafting")
```

The github repository [ossl-imports](https://github.com/soilspectroscopy/ossl-imports) has all the importing codes for preparing and integrating new datasets into the OSSL. The folder [ossl-imports/dataset](https://github.com/soilspectroscopy/ossl-imports/tree/main/dataset) contains all the datasets separated by its name/code, with an internal `README` file describing in detail the steps necessary for preparing and standardizing the files into the OSSL format.

The original files are placed on an internal server to avoid the storage of big files in the github repository, but some of them can be found on persistent online repositories if they have a public license. Other original datasets that do not have a public license or are shared to this project with some restrictions will no be shared publicly. As we keep the original files in a local repository to run the importing notebooks (each `ossl-imports/dataset/../README.Rmd`), this operation can only be run at our internal server. New contributors are encouraged to host their files on a public repository and draft the importing step on github through pull requests. The final checks and consolidation, however, will be concluded on an internal server.

The `README` files follow a basic structure. Each one has a description of the dataset at the top of the notebook which links to the dataset source and references. An extended description is provided in the [OSSL-manual](https://soilspectroscopy.github.io/ossl-manual/soil-spectroscopy-tools-and-users.html#registered-soil-spectral-libraries) as well.

For preparing the import, the following subsections are defined:

- Basic description.
- Soil site information.
- Soil laboratory (wet chemistry) information.
- Mid-infrared (MIR) spectroscopy data (optional).
- Visible-near-infrared (VisNIR) spectroscopy data (optional).
- Quality control.
- References.

Each subsection has its own reading and processing functions, and the outputs can be joined using shared id columns. The output files share the same name and pattern but can be retrieved with different folder names, which are binded together in a final stage. The outputs are `ossl_soilsite_<version>.qs`, `ossl_soillab_<version>.qs`, `ossl_mir_<version>.qs`, `ossl_visnir_<version>.qs`. The version is adjusted in the recurring updates.

The contrasting methods used for analytically determining (wet chemistry) a given soil property has also been a subject of internal discussion in this project. Some global initiatives have been facing this same issue in their soil databases but there still no clear or full consensus on how to harmonize those different methods. This has been a topic of great discussion and research development at the [Global Soil Partnership’s Global Soil Laboratory Network (GLOSOLAN)](https://www.fao.org/global-soil-partnership/glosolan/en/).

In order to maximize transparency, for now, we have decided to produce two different levels for the OSSL database. `Level 0` takes into account the original methods employed in each dataset but tries to initially fit them to two reference lists: [KSSL Guidance – Laboratory Methods and Manuals](https://www.nrcs.usda.gov/resources/guides-and-instructions/kssl-guidance) and ISO standards. A copy of the KSSL procedures and coding scheme is archived in [ossl-imports](https://github.com/soilspectroscopy/ossl-imports/blob/main/out/kssl_procedures.csv).

If a reference method does not fall in any previous method, then we create a new variable sharing at least a common property and unit. A final harmonization takes place in the OSSL `Level 1`, where those common properties sharing different methods are converted to a target method using some publicly available transformation rule, or in the worst scenario, they are naively binded or kept separated to produce its specific model. All the implementations are documented in the [ossl-import](https://github.com/soilspectroscopy/ossl-imports/blob/main/out/ossl_level0_to_level1_soillab_harmonization.csv) repository.

The following subsections provide the OSSL variable names, types, description, and example. You can also find all this information in tabular format:

- [OSSL soil site data](./tabular/ossl_level0_names_soilsite.csv).
- [OSSL soil lab data (level 0)](./tabular/ossl_level0_names_soillab.csv).
- [OSSL soil lab data (level 1)](./tabular/ossl_level1_names_soillab.csv).
- [OSSL soil MIR data](./tabular/ossl_level0_names_mir.csv).
- [OSSL soil VisNIR data](./tabular/ossl_level0_names_visnir.csv).

```{r config, echo=FALSE}
knitr::opts_chunk$set(message = FALSE)
knitr::opts_chunk$set(warning = FALSE)
```

```{r load_data, include=FALSE, eval=FALSE}
library("tidyverse")
library("readr")
library("qs")
library("curl")
library("captioner")
library("openair")

fig_nums <- captioner(prefix = "Fig.")
source("R/ossl_functions.R")

ossl.soilsite <- "https://storage.googleapis.com/soilspec4gg-public/ossl_soilsite_L0_v1.2.qs"
ossl.soilsite <- curl_fetch_memory(ossl.soilsite)
ossl.soilsite <- qdeserialize(ossl.soilsite$content) %>% as_tibble()

ossl.soillab.level0 <- "https://storage.googleapis.com/soilspec4gg-public/ossl_soillab_L0_v1.2.qs"
ossl.soillab.level0 <- curl_fetch_memory(ossl.soillab.level0)
ossl.soillab.level0 <- qdeserialize(ossl.soillab.level0$content) %>% as_tibble()

ossl.soillab.level1 <- "https://storage.googleapis.com/soilspec4gg-public/ossl_soillab_L1_v1.2.qs"
ossl.soillab.level1 <- curl_fetch_memory(ossl.soillab.level1)
ossl.soillab.level1 <- qdeserialize(ossl.soillab.level1$content) %>% as_tibble()
```

```{r density_plots, include=FALSE, eval=FALSE}
library("ggplot2")
library("viridis")
library("ggridges")
library("rlang")
library("moments")

names.remove <- c("dataset.code_ascii_txt", "id.layer_uuid_txt", "efferv_usda.a479_class")

ossl.soillab.level0.names <- ossl.soillab.level0 %>%
  select(-all_of(names.remove)) %>%
  names()

# Switch to:
# https://r-charts.com/correlation/heat-map-ggplot2/

for(i in 1:length(ossl.soillab.level0.names)) {
  
  isoil.property <- ossl.soillab.level0.names[i]
  
  out.png = paste0("./hist_v1.2/hist_L0_", isoil.property, ".png")
  
  plot.df = ossl.soillab.level0 %>%
    select(dataset.code_ascii_txt, all_of(isoil.property))
  
  iskewness <- plot.df %>%
    pull(all_of(isoil.property)) %>%
    skewness(na.rm = T)
  
  i99th <- plot.df %>%
    summarise(!!isoil.property := quantile(!!as.name(isoil.property), p = 0.99, na.rm = T)) %>%
    pull(all_of(isoil.property))
  
  if(iskewness <= -3 | iskewness >= 3) {
    
    plot.df <- plot.df %>%
      mutate(!!isoil.property := ifelse(!!as.name(isoil.property) < 0.001, 4096, !!as.name(isoil.property))) %>%
      filter(!!as.symbol(isoil.property) < i99th) %>%
      mutate(!!isoil.property := log2(!!as.name(isoil.property))) %>%
      mutate(!!isoil.property := ifelse(!!as.name(isoil.property) == 12, 0, !!as.name(isoil.property)))
    
    n.table <- plot.df %>%
      filter(!is.na(!!as.symbol(isoil.property))) %>%
      count(dataset.code_ascii_txt) %>%
      mutate(!!isoil.property := {plot.df %>%
          summarise(!!isoil.property := max(!!as.name(isoil.property), na.rm = T)) %>%
          pull(all_of(isoil.property))*1.1})
    
    plot <- ggplot(plot.df, aes(x = !!sym(isoil.property), y = dataset.code_ascii_txt, fill = ..x..)) +
      geom_density_ridges_gradient(scale = 1, rel_min_height = 0.01, gradient_lwd = 1.) +
      scale_x_continuous(expand = c(0.01, 0)) +
      scale_y_discrete(expand = c(0.01, 0)) +
      scale_fill_viridis(option = "C") +
      geom_text(data = n.table, aes(label = paste0("n=", n)), vjust = -0.5, hjust = "inward") +
      labs(title = paste0("log2(", isoil.property, ")"), fill = "", x = "", y = "") +
      theme_ridges(grid = TRUE, font_size = 13) +
      theme(panel.background = element_rect(fill = 'white'),
            plot.background = element_rect(fill = 'white'))
    
  } else {
    
    plot.df <- plot.df %>%
      filter(!!as.symbol(isoil.property) < i99th)
    
    n.table <- plot.df %>%
      filter(!is.na(!!as.symbol(isoil.property))) %>%
      count(dataset.code_ascii_txt) %>%
      mutate(!!isoil.property := {plot.df %>%
          summarise(!!isoil.property := max(!!as.name(isoil.property), na.rm = T)) %>%
          pull(all_of(isoil.property))*1.2})
    
    plot <- ggplot(plot.df, aes(x = !!sym(isoil.property), y = dataset.code_ascii_txt, fill = ..x..)) +
      geom_density_ridges_gradient(scale = 1, rel_min_height = 0.01, gradient_lwd = 1.) +
      scale_x_continuous(expand = c(0.01, 0)) +
      scale_y_discrete(expand = c(0.01, 0)) +
      scale_fill_viridis(option = "C") +
      geom_text(data = n.table, aes(label = paste0("n=", n)), vjust = -0.5, hjust = "inward") +
      labs(title = isoil.property, fill = "", x = "", y = "") +
      theme_ridges(grid = TRUE, font_size = 13) +
      theme(panel.background = element_rect(fill = 'white'),
            plot.background = element_rect(fill = 'white'))
    
  }
  
  ggsave(out.png, plot, width = 7, height = 7, units = "in", scale = 1)
  
}
```

## Soilsite data {#sites-table}

Observations and measurements at the site level. For the **site** table please use (at least) the following columns.

```{r reference_soilsite, results='asis', echo=FALSE}
library("tidyverse")
library("readr")
soilsite.level0.desc <- read_csv("./tabular/ossl_level0_names_soilsite.csv")

for (i in 1:nrow(soilsite.level0.desc)) {
  
  iossl_name <- soilsite.level0.desc[[i,"ossl_name"]]
  itype <- soilsite.level0.desc[[i,"type"]]
  iexample <- soilsite.level0.desc[[i,"example"]]
  idescription <- soilsite.level0.desc[[i,"description"]]
  
  cat(paste0('\n\n### ', iossl_name))
  cat(paste0('\nDescription: ', idescription, '.'))
  cat(paste0('\nType: ', itype, '.'))
  cat(paste0('\nExample: ', iexample, '.'))

}
```

## Soillab data {#soillab-table}

```{r reference_soillab, results='asis', echo=FALSE}
soillab.level0.desc <- read_csv("./tabular/ossl_level0_names_soillab.csv")

for (i in 1:nrow(soillab.level0.desc)) {
  
  iossl_name <- soillab.level0.desc[[i,"ossl_name"]]
  idescription <- soillab.level0.desc[[i,"description"]]
  ianalyte <- soillab.level0.desc[[i,"analyte"]]
  iunit <- soillab.level0.desc[[i,"ossl_unit"]]
  iunit_description <- soillab.level0.desc[[i,"unit_description"]]
  itype <- soillab.level0.desc[[i,"type"]]
  iexample <- soillab.level0.desc[[i,"example"]]
  
  cat(paste0('\n\n### ', iossl_name))
  cat(paste0('\nDescription: ', idescription, '. The analyte can be simply described as `', ianalyte, '`.'))
  cat(paste0('\nUnit: Imported into the OSSL as `', iunit, '`, i.e., ', iunit_description, '.'))
  cat(paste0('\nType: ', itype, '.'))
  cat(paste0('\nExample: ', iexample, '.'))
  if(file.exists(paste0("hist_v1.2/hist_L0_", iossl_name, ".png"))) {
    cat(paste0('\n<img src="./hist_v1.2/hist_L0_',iossl_name, '.png" heigth=100% width=100%>'))
  }
  
}
```

## MIR scans {#mir-table}

Middle-infrared (MIR) spectra is provided in absorbance units per wavenumber, with values usually ranging between 0 and 3. The spectral range imported into the OSSL falls between 600 and 4000 cm<sup>-1</sup>, with an interval of 2 cm<sup>-1</sup>. All datasets are harmonized to this specification.

One can convert reflectance (R) values to absorbance units (A) as `A = log10(1/R)`, or backtransform with `R = 1/(10^A)`. Similarly, wavenumber (WN, in cm<sup>-1</sup>) can be converted to wavelength (WL, in nm) with `WN = 1/(WL*10000000)`, or backtransform with `WL = 1/(WL*10000000)`. The factor 10M is used to convert cm to nm.

```{r reference_mir, results='asis', echo=FALSE}
mir.level0.desc <- read_csv("./tabular/ossl_level0_names_mir.csv")

for (i in 1:nrow(mir.level0.desc)) {
  
  iossl_name <- mir.level0.desc[[i,"ossl_name"]]
  itype <- mir.level0.desc[[i,"type"]]
  iexample <- mir.level0.desc[[i,"example"]]
  idescription <- mir.level0.desc[[i,"description"]]
  
  cat(paste0('\n\n### ', iossl_name))
  cat(paste0('\nDescription: ', idescription, '.'))
  cat(paste0('\nType: ', itype, '.'))
  cat(paste0('\nExample: ', iexample, '.'))
  
}
```

## VisNIR scans {#visnir-table}

Visible and Near-Infrared (VisNIR) spectra is provided in reflectance units per wavelength, with values usually ranging between 0 and 1 as fraction percent. The spectral range imported into the OSSL falls between 350 and 2500 nm, with an interval of 2 nm. All datasets are harmonized to this specification.

One can convert reflectance (R) values to absorbance units (A) as `A = log10(1/R)`, or backtransform with `R = 1/(10^A)`. Similarly, wavenumber (WN, in cm<sup>-1</sup>) can be converted to wavelength (WL, in nm) with `WN = 1/(WL*10000000)`, or backtransform with `WL = 1/(WL*10000000)`. The factor 10M is used to convert cm to nm.

```{r reference_visnir, results='asis', echo=FALSE}
visnir.level0.desc <- read_csv("./tabular/ossl_level0_names_visnir.csv")

for (i in 1:nrow(visnir.level0.desc)) {
  
  iossl_name <- visnir.level0.desc[[i,"ossl_name"]]
  itype <- visnir.level0.desc[[i,"type"]]
  iexample <- visnir.level0.desc[[i,"example"]]
  idescription <- visnir.level0.desc[[i,"description"]]
  
  cat(paste0('\n\n### ', iossl_name))
  cat(paste0('\nDescription: ', idescription, '.'))
  cat(paste0('\nType: ', itype, '.'))
  cat(paste0('\nExample: ', iexample, '.'))
  
}
```
<!-- ## Harmonization rules -->

<!-- The following description includes harmonization/conversion rules recommended in this project. -->
<!-- For each conversion rule, a reference and an example are provided to prevent from  -->
<!-- misusing the rules. The following principle of harmonization are highly recommended: -->

<!-- 1. Document (R code) any harmonization / conversion steps.\ -->
<!-- 2. Where possible provide propagated measure of uncertainty. This can further used  -->
<!-- as weights in the Machine Learning / model building.\ -->
<!-- 3. Any conversion that leads to inducting significant bias (over-/under-estimation  -->
<!-- of values) should we avoided.\ -->
<!-- 4. Add to the produced dataset metadata that part of data has been harmonized and  -->
<!-- specify exact method.\ -->

<!-- Disclaimer: use at own risk. See also our general disclaimer. -->

<!-- ### pH -->

<!-- From `ph.kcl_usda.4c1_index` to `ph.h2o_usda.4c1_index` based on @bohner2008saga: -->

<!-- ```{r} -->
<!-- ph.kcl = 6.5 -->
<!-- ph.h2o = ph.kcl / 0.87 -->
<!-- ph.h2o -->
<!-- ``` -->

<!-- From `ph.cacl2_usda.4c1_index` to `ph.h2o_usda.4c1_index` based on @miller2010comparison: -->

<!-- ```{r} -->
<!-- ph.cacl2 = 6.5 -->
<!-- ph.h2o = (ph.cacl2 + 0.973 ) / 1.08 -->
<!-- ph.h2o -->
<!-- ``` -->


<!-- ### Carbon -->

<!-- From `humus_usda.4h2_wpct` to `oc_usda.4h2_wpct` based on @nelson1983total: -->

<!-- ```{r} -->
<!-- humus = 4 -->
<!-- oc = humus / 1.724 -->
<!-- oc -->
<!-- ``` -->

<!-- From `humus_usda.4h2_wpct` to `oc_usda.4h2_wpct` based on @jensen2018converting: -->

<!-- ```{r} -->
<!-- humus = 4; clay = 10 -->
<!-- oc1 = 0.513 * humus - (0.047 * clay - 0.00025 * clay^2) -->
<!-- oc1 -->
<!-- humus = 4; clay = 20 -->
<!-- oc2 = 0.513 * humus - (0.047 * clay - 0.00025 * clay^2) -->
<!-- oc2 -->
<!-- ``` -->

<!-- ### Phosphorous -->

<!-- ### Potassium -->

<!-- ### Nitrogen -->

<!-- ### Exchangeable cations and CEC -->

<!-- From `k.ext` extracted by Mehlich-3 (cmol/kg) to `ecec.ext_usda.4b1_cmolkg` based on @helling1964contribution: -->

<!-- ```{r} -->
<!-- ph.h2o = 6.5 -->
<!-- k.ext = 2 -->
<!-- ca.ext = 12 -->
<!-- na.ext = 2 -->
<!-- mg.ext = 1 -->
<!-- ecec.ext = ifelse(ph.h2o < 7.5 & ph.h2o>4, (k.ext + ca.ext + na.ext + mg.ext), NA) -->
<!-- ecec.ext -->
<!-- ``` -->

<!-- From `oc_usda.4h2_wpct` to `ecec.ext_usda.4b1_cmolkg` based on @helling1964contribution: -->

<!-- ```{r} -->
<!-- clay.tot = 28 -->
<!-- ph.h2o = 6.5 -->
<!-- oc = 2 -->
<!-- ecec.ext = ((clay.tot*10/100*(30+4.4*ph.h2o))+(oc/100*(-59+51*ph.h2o)))/10 -->
<!-- ecec.ext -->
<!-- ``` -->

<!-- ### Texture fractions -->

<!-- ### Bulk density -->

<!-- ### Soil biological variables -->

<!-- ### Soil contaminants -->

